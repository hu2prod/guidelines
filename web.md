# Веб разработка
**ВАЖНО** Документ всё еще дорабатывается
## Предпосылки
В основном факты
  * Чем больше суммарный размер всех файлов, тем дольше грузится сайт
  * Чем больше запросов, тем дольше грузится сайт
  * Существует минимальный размер сайта после которого скорость загрузки радикально улучшить сложнее чем до. Это размер 1 пакета данных.
    * Можно считать минимальным пакетом TCP
    * Можно считать минимальным пакетом MTU
      * Ethernet имеет [MTU](https://ru.wikipedia.org/wiki/Maximum_transmission_unit) 1500 байт (RFC 1191)
    * TCP имеет ACK, а фрагмент помещающийся в MTU не имеет. И это будет важно дальше.
  * Максимальная скорость загрузки сайта ограничена следующими пределами, из которых наименьший является узким звеном
    * Скорость клиента (с учётом того, что он качает еще что-то еще.)
      * Является узким местом у мобильных клиентов
    * Скорость сервера (с учётом того, что он раздает многим клиентам.)
      * Обычно не является узким местом
    * Latency от клиента к серверу (обычно одинаково ко всем серверам т.к. основное latency приходится на канал до проводного/оптического провайдера)
      * После уменьшения размера сайта до 1 пакета данных скорость в пакетах в секунду больше не влияет на загрузку сайта
    * [RTT](https://en.wikipedia.org/wiki/Round-trip_delay_time) cwnd
      * Подробнее про cwnd [eng](https://blog.stackpath.com/glossary/cwnd-and-rwnd/) [rus](https://habr.com/company/oleg-bunin/blog/319114/)
      * Пример. Если cwnd=4 пакета отослано и ни у одного не получен ack, то следующие пакеты не будут отосланы.
        * А скорость позволяет и больше пакетов переслать, но теперь ограничением является rtt+cwnd
      * cwnd непостоянен при tcp сессии и медленно увеличивается если все пакеты доходят и резко уменьшается если есть потери пакетов.
      * У cwnd есть начальное значение Initial cwnd
  * Размер [jumbo frame](https://en.wikipedia.org/wiki/Jumbo_frame) < 9000 байт 
  * В основном (99+%) мы не можем заставить пользователя сменить провайдера ради нашей услуги
  * Сайт, который грузится по https с большой вероятностью может загрузиться БЫСТРЕЕ чем по http [подробности](https://habr.com/company/oleg-bunin/blog/319114/)
  * Читаемый текст должен удовлетворять следующим условиям
    * Однородный фон
    * Контрастный фон
## Принципы
### Общие
Не обязательно факты, которые справедливы всегда, но мы принимаем их
  * Все программные продукты условно делятся на две большие категории
    * Сначала разработчик много потратил времени и напрягался, пользователь потом тратит мало времени и **не** напрягается.
    * Сначала разработчик потратил мало времени и **не** напрягался, а пользователь потом тратит много времени и напрягается.
    * Мы выбираем первый путь. В основном напрягаться это нормально, но кое-что что занимает слишком много времени или слишком сложное мы таки делать не будем.
  * Людям не нравится когда их учат "как правильно жить"
    * Мы **не** указываем пользователю как он должен делать, **не** учим пользователя "как правильно жить", **не** навязываем свое мнение.
      * Мы **не** указываем, что пользователю нужно сменить браузер
      * Мы **не** указываем, что пользователю нужно не работать с мобилочки, а зайти с нормального компа
    * Мы должны предоставить пользователю самый лучший user experience, если мы это можем сделать на технических возможностях пользователя
      * У нас должна быть поддержка самых передовых технологий, если это статистически измеримо улучшит user experience
    * Мы должны предоставить пользователю хоть какой-то user experience, если у пользователя неидеальные условия
      * У нас должна быть поддержка самого отсталого браузера из тех, что в списке поддерживаемых браузеров.
        * Промежуточные технологии можно не поддерживать. Только bleeding edge и fallback.
      * Текст должен быть читаемым
        * Нет обоснования "У пользователя шрифт не поддерживается"
      * Контролы должны быть видимыми, иметь возможность реагировать и реагировать на действия пользователя
        * Нет обоснования "Наши контролы работают только в IE9+"
      * Если приложению нужна сеть для работы, то пакеты должны ходить по сети
        * Нет обоснования "У пользователя нет технологии `X`, потому пакеты не ходят по сети"
  * Пользователь не идиот, если он видит, что проблемы с сетью, он попробует починить, но делать это постоянно он не будет
    * Если есть какая-то проблема, которая решается при помощи F5, и она вызвана плохой сетью у пользователя, мы можем не решать эту проблему никак.
      * Но мы должны решать любую проблему единичного битого запроса и/или разорванного соединения после того как сайт полностью загрузился.
  * Приоритет между "обслуживать лучше тех, что уже есть" и "искать новых клиентов" всегда должен быть на "обслуживать лучше тех, что уже есть", но 10% времени всё-таки необходимо уделять на расширение поддержки.
    * Поддержка браузеров и недопустимая технологическая дискриминация
      * Для информационного сайта
        * У пользователя мобильный телефон/интернет и поэтому он не может получить информацию
      * Для интерактивного сайта
        * У пользователя не поддерживается какая-то веб-технология и из-за этого весь сайт или какой-то критичный кусок бизнес-процесса не работает
    * Допустимая дискриминация
      * Исходя из крайностей по конверсии
        * Пускай наша конверсия 1%. 0.1% пользователей это 10% от конверсии. Ок, пускай мы отрезали пользователей которые 100% конвертят (хотя это не так). Нас это устраивает.
          * Контрпример. Мы отрезали 1% пользователей. Ок... у них вообще в интернете ничего не работает... а наш сайт работает... у нас там будет сильно лучше конверсия чем у конкурентов.
        * Пускай наша конверсия 10%. 0.1% пользователей это еще 1% улучшение метрики. Нет мы не будем дальше улучшать поддержку браузеров т.к. +-5% только от смены landing page'а.
          * Контрпример. 1% браузеров это уже 10%. Таки эти пользователи еще интересны см. обоснование выше.
      
### Технические
  * Наши клиенты используют HTTP 1.1 (и не поддерживают HTTP 2 и SPDY)
  * Мы считаем что у наших клиентов есть gzip, тем более если они на мобильном соединении
  * Мы принимаем следующие константы для всех расчетов
    * Initial cwnd = 10
    * Для проводного клиента
      * RTT = 50 ms (считаем, что это хороший пинг до google, у проводного пользователя будет в среднем такой же)
        * (источник мой текущий провайдер)
    * Для мобильного клиента
      * RTT = 350 ms (пессимистичный для 3G, очень оптимистичный для 2G)
        * [Источник](https://www.evdoinfo.com/content/view/4818/64/)
        * [По разным городам с 2G](https://mybroadband.co.za/vb/showthread.php/173300-2G-EDGE-Network-performance-tests)
          * Может доходить до секунд.
    * Мы считаем что 1 TCP пакет меньше 9000 байт с заголовком и полностью влезает в frame в той сети, которой пользуется пользователь, либо будет получать фрагменты достаточно быстро, по сравнению с другим отдельным TCP пакетом.
  * Все пакеты, которые успевают до отметки в initial cwnd приходят достаточно быстро и почти одновременно, initial cwnd+1 пакет может прийти с существенной задержкой за счет большого RTT.
  * В идеале мы должны успеть передать ВЕСЬ наш сайт за 10 TCP пакетов
    * 10 берется из initial cwnd
    * Мы будем приравнивать 10 TCP пакетов к 10 полным запросам к сайту
    * Суммарный объем данных который можно передать в 10 TCP пакетах мы будем считать равным 90 Кб.
      * Чем больше мы делаем мелких запросов по меньше чем 9000 байт, тем меньше наш итоговый бюджет
  * Не получив html, мы не знаем какие js,css,img нужно качать
  * Мы можем выбрать одно из двух
    * Мы хотим что бы пользователь не перекачивал js и css для каждой страницы
      * Мы не будем вставлять js и css в html
      * В этом случае пользователь будет ждать 2 RTT до полной загрузки сайта
        * На самом деле 1.5 RTT т.к. от того, что сервер получит или не получит ACK клиенту ни холодно ни жарко
      * Бюджет сайта
        * 90 Кб html
        * 90 Кб на js, css, font, img
    * У нас одностраничное приложение и/или мы хотим доставить пользователю как можно больше и/или после чего пользователь уйдет и/или нам нужно показать много контента быстоо
      * Мы вставляем js и css в основной html
      * В этом случае пользователь будет ждать 1 RTT до частичной загрузки сайта и 2 RTT до полной
        * На самом деле 0.5 RTT и 1.5 RTT соответственно см. выше обоснование.
      * Бюджет сайта
        * 90 Кб на html js и css
        * 90 Кб на font, img и media
  * Вне разницы какой сценарий мы выберем, если мы уместимся в 90 Кб html + js + css + font, то мы по-любому будем быстрыми как бы мы не настроили наш сервер.
  * Мы можем стараться уместиться в 1 TCP пакет для оптимального минимального отображения страницы
    * Мы этого **не** будем делать без дополнительного обоснования зачем нам нужно настолько быстро загружать сайт.
      * ~~Торт со взбитыми сливками подойдет~~ Не объясняя ничего, но добавив денег в бюджет мы это сделаем и будем поддерживать (продолжая на это тратить деньги заказчика).

  * Нет повода для использования http, "потому что он быстрее" для открытого интернета
  * Вероятно, мы разрабатываем динамическое приложение. Потому мы не сможем нормально работать в браузерах, которые не поддерживают javascript (или выключили его через плагин).
  
  * Поддержка браузеров
    * [статистика](https://caniuse.com/usage-table)
    * [desktop vs mobile vs tablet](http://gs.statcounter.com/platform-market-share/desktop-mobile-tablet)
    * Мы считаем процент для desktop отдельно, для mobile отдельно
    * Для информационных сайтов
      * Мы поддерживаем любой браузер, у которого usage больше 0.1% в сегменте (desktop 0.043% mobile 0.053%)
        * major
          * Chrome (29, 43, 48+)
          * firefox (38, 47, 48, 51+)
          * safari (5.1)
          * iOS safari (7.1, 8.4+, 9.1+)
          * Opera 53 (last)
        * bad
          * IE8+
          * Opera Mini
          * UC Browser
          * IE Mobile 11
        * extra
          * Chrome for Android
          * Android Browser 4.1+
          * Firefox for Android
      * Таки не поддерживаем
        * IE6, IE7
        * Blackberry Browser
        * Opera Mobile (не путать с opera mini)
        * QQ Browser, Baidu Browser
      * Тесты на получения скриншотов в этих браузерах должны быть
    * Для интерактивного сайта
      * Мы поддерживаем любой браузер, у которого usage больше 1% в сегменте (desktop 0.43% mobile 0.53%)
        * Major
          * Chrome last 2 versions
          * IE 11, EDGE last
          * Firefox, Safari most used version
          * iOS safari (10.3+)
        * Bad
          * Opera mini
          * UC Browser
        * Extra
          * Chrome for Android
          * Android browser (4.4)
      * Тесты на каждое критическое интерактивное действие должны быть
    * Для сайта, который требует загрузки файлов, та часть, которая требует загрузки файлов может не проверяться на мобильных устройствах.
    * Поддержка браузеров должна вводиться от самых популярных браузеров к менее популярным
      * Если мы таки не поддерживаем под какой-то браузер, то единственным обоснованием является, что мы в процессе починки поддержки браузера который выше по популярности
      * Под починкой поддержки также подразумевается написание тестов
  * Размещать css вверху или внизу?
    * Если размещать как ссылку
      * Чем раньше разместим, тем раньше пользователь задекодирует потоково gzip, найдет строку подключения css и раньше начнёт качать css в параллельном соединении.
    * Если размещать как текст
      * Если весь html+сss помещается в 9000 байт gzip, то вероятно, что он закачается одним TCP пакетом и без разницы как мы будем ставить
        * Потому по-умолчанию ставим в этом случае вверху чтобы 100% не было промигивания хреново отрендеренного сайта
      * Если больше 9000 байт
        * Окончание фрагмента html+css приходится до 9000 байта при размещении вверху (с учётом gzip)
          * Вверху. Сайт будет грузиться долго, и если разместим такой мизерный css внизу... то смысл?
        * Иначе
          * Есть вопросы к автору
            * Почему так много html до начала css?
            * Почему css такой большой? 9kb gzip при pack ratio 4 это 36 Кб незапакованного.
              * Забыли minify?
              * Вставили дофига base64?
                * Может разбить на 2 css и base64 вынести в отдельный файл, который будет грузиться отдельно со всеми asset'ами?
                * Может запакуем много base64 в спрайт?
              * bootstrap?
                * Сколько класов мы с него реально используем? Больше 50%?
              * После решения всех вопросов скатываемся в решения выше, и опять таки размещаем основное вверху.
                * Дополнительный css с asset'ами можно разместить внизу т.к. вверху+defer не вариант т.к. клиент может не поддерживать defer и от разделения тогда толку почти никакого.
  * Для популярных библиотек ссылаться на CDN или раздавать самим.
    * История из жизни. Я очень хорошо помню как у нас упал java сервис, который имел spring и/или hibernate который при старте запрашивал какой-то xml с вендорского сайта. И как у нас всё упало, когда вендорский сайт почему-то упал. И уронил за собой всё.
    * История из жизни. Когда падает amazon падает добрый сегмент интернета. Посмотрите на статистику сколько раз падал amazon. Это не настолько редкое событие в прошлом. Можем повторить.
    * Кто-то может решить, что библиотека устарела и убрать её у себя. А наш сайт должен работать.
    * Гуглу может стать невыгоден CDN и он закроет его как закрыл много других своих сервисов. Это же может касаться не CDN.
    * За свои сервера отвечаешь ты, за чужие сервера ты вообще ничего не знаешь и узнаешь, когда всё упало и потом все-равно переделаешь так как надо было сделать сначала.
    * Вывод. Весь интернет может упасть, а наш сайт должен работать. Храним всё у себя.
  * Использовать чужой компонент, или написать свой?
    * Компонент имеет в зависимостях какие-то библиотеки, которые мы не используем?
      * jquery, lodash
    * Компонент имеет размер больше 50 Кб до gzip?
    * Компонент имеет необоснованно большой размер относительно нужной нам функциональности?
    * Компонент нас чем-то не устраивает? Компонент нужно будет доделывать?
    * Ответ на любой вопрос да - повод не использовать, а переписать с оглядкой на свои потребности, а не на потребности всех-всех-всех в интернете, кто задолбал автора feature request'ами которые добавили туда и отключить нельзя т.к. 90-99% компонентов в интернете не конфигурируются.
    * "Нам сейчас быстро в прототип, потом выпилить"
      * Прототип в codepen или в отдельный webpack demo проект.
      * На прод к себе мы это тащить будем только после того как пройдем checklist выше.

## Tuning serverside
### Роутинг с прицелом на highload
  * Прим. Рецепт очень странный и так никто не делает
  * Вместо многих URL в одном приложении делается по приложению на каждый URL
  * Вместо подставлять nodejs напрямую в мир, подставлять nginx, который будет сшивать роутинг
  * Плюсы
    * RPS не shared между всеми URL. Если какую-то страницу активно долбят, остальные живы
    * Плодим соединения с базой только на страничках, на которых действительно нужно соединение с базой
    * Увеличиваем количество instance'ов только на горячих URL
    * Мы можем переписать одну страничку на Rust и получить много больше RPS чем на Node.js
      * И при этом нам не нужно переписывать на Rust вообще всё. Строго необходимый минимум.
    * Улучшенная отказоустойчивость
      * Если в обработчике какой-то страницы ошибка, то она не роняет весь сервер
  * Минусы
    * Так никто не делает
    * Без кодогенерации поддерживать невозможно
    * Нет общих кэшей на приложение. Но это хорошо, сразу приучивает, что так делать не желательно
